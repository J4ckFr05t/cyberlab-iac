---
- name: Install Prerequisites (GPG)
  apt:
    name: gpg
    state: present
  become: yes
  register: apt_result
  retries: 5
  delay: 10
  until: apt_result is success

# Note: Authentication uses elastic_custom_password from Vault

- name: Wait for Kibana to be ready
  wait_for:
    host: "{{ hostvars['siem-01-srv']['ansible_host'] }}"
    port: 5601
    delay: 10
    timeout: 300
    state: started
  become: no

- name: Pause for Kibana Initialization
  pause:
    seconds: 15

- name: Create Fleet Server Policy
  uri:
    url: "http://{{ hostvars['siem-01-srv']['ansible_host'] }}:5601/api/fleet/agent_policies?sys_monitoring=true"
    method: POST
    user: elastic
    password: "{{ elastic_custom_password }}"
    force_basic_auth: yes
    headers:
      kbn-xsrf: "true"
      Content-Type: "application/json"
    body_format: json
    body:
      name: "Fleet Server Policy"
      description: ""
      namespace: "default"
      monitoring_enabled: ["logs", "metrics", "traces"]
      has_fleet_server: true
      inactivity_timeout: 1209600
      is_protected: false
    status_code: [200, 409] # 409 if already exists
  register: fleet_policy_response
  failed_when: fleet_policy_response.status != 200 and fleet_policy_response.status != 409

- name: Set Policy ID Fact (Created)
  set_fact:
    fleet_policy_id: "{{ fleet_policy_response.json.item.id }}"
  when: fleet_policy_response.status == 200

- name: Fetch Existing Policies (Fallback)
  uri:
    url: "http://{{ hostvars['siem-01-srv']['ansible_host'] }}:5601/api/fleet/agent_policies"
    method: GET
    user: elastic
    password: "{{ elastic_custom_password }}"
    force_basic_auth: yes
    headers:
      kbn-xsrf: "true"
  register: existing_policies
  when: fleet_policy_response.status == 409

- name: Set Policy ID Fact (Existing)
  set_fact:
    fleet_policy_id: "{{ existing_policies.json['items'] | selectattr('name', 'equalto', 'Fleet Server Policy') | map(attribute='id') | first }}"
  when: fleet_policy_response.status == 409

# Fallback: If policy exists (409), we need to fetch it to get the ID. 
# For now, assuming fresh install or idempotent skip if we can't get ID easily without another query.
# But for this specific flow, let's assume valid creation.

- name: Add Fleet Server Package to Policy
  uri:
    url: "http://{{ hostvars['siem-01-srv']['ansible_host'] }}:5601/api/fleet/package_policies"
    method: POST
    user: elastic
    password: "{{ elastic_custom_password }}"
    force_basic_auth: yes
    headers:
      kbn-xsrf: "true"
      Content-Type: "application/json"
    body_format: json
    body:
      policy_ids: ["{{ fleet_policy_id }}"]
      package:
        name: "fleet_server"
        version: "1.6.0"
      name: "Fleet Server"
      description: ""
      namespace: ""
      inputs:
        fleet_server-fleet-server:
          enabled: true
          vars:
            custom: ""
          streams: {}
    status_code: [200, 409]
  when: fleet_policy_id is defined

- name: Delete Existing Service Token
  uri:
    url: "https://{{ hostvars['siem-01-srv']['ansible_host'] }}:9200/_security/service/elastic/fleet-server/credential/token/fleet-01-srv"
    method: DELETE
    user: elastic
    password: "{{ elastic_custom_password }}"
    force_basic_auth: yes
    headers:
      kbn-xsrf: "true"
    validate_certs: no
    status_code: [200, 404]

- name: Generate Service Token
  uri:
    url: "https://{{ hostvars['siem-01-srv']['ansible_host'] }}:9200/_security/service/elastic/fleet-server/credential/token/fleet-01-srv"
    method: POST
    user: elastic
    password: "{{ elastic_custom_password }}"
    force_basic_auth: yes
    headers:
      kbn-xsrf: "true"
    validate_certs: no
  register: service_token_response

- name: Set Service Token Fact
  set_fact:
    fleet_service_token: "{{ service_token_response.json.token.value }}"

- name: Download Elastic Agent
  get_url:
    url: https://artifacts.elastic.co/downloads/beats/elastic-agent/elastic-agent-9.2.2-amd64.deb
    dest: /tmp/elastic-agent-9.2.2-amd64.deb

- name: Install Elastic Agent (with Flavor)
  shell: "ELASTIC_AGENT_FLAVOR=servers dpkg -i /tmp/elastic-agent-9.2.2-amd64.deb"
  become: yes
  register: shell_result
  retries: 5
  delay: 10
  until: shell_result is success

- name: Enable and Start Elastic Agent Service
  systemd:
    name: elastic-agent
    enabled: yes
    state: started
  become: yes

- name: Read CA Fingerprint from Local Controller
  local_action:
    module: slurp
    src: "{{ playbook_dir }}/../files/trusted_ca_fingerprint"
  register: fingerprint_file
  become: no

- name: Set Fingerprint Fact
  set_fact:
    ca_fingerprint: "{{ fingerprint_file['content'] | b64decode | trim }}"

- name: Enroll Elastic Agent (Fleet Server)
  shell: |
    elastic-agent enroll \
      --fleet-server-es=https://{{ hostvars['siem-01-srv']['ansible_host'] }}:9200 \
      --fleet-server-service-token={{ fleet_service_token }} \
      --fleet-server-policy={{ fleet_policy_id }} \
      --fleet-server-es-ca-trusted-fingerprint={{ ca_fingerprint }} \
      --fleet-server-port=8220 \
      --force
  become: yes
  when: 
    - fleet_policy_id is defined
    - fleet_service_token is defined

- name: Configure Default Fleet Server Host
  uri:
    url: "http://{{ hostvars['siem-01-srv']['ansible_host'] }}:5601/api/fleet/fleet_server_hosts"
    method: POST
    user: elastic
    password: "{{ elastic_custom_password }}"
    force_basic_auth: yes
    headers:
      kbn-xsrf: "true"
      Content-Type: "application/json"
    body_format: json
    body:
      name: "{{ inventory_hostname }}"
      is_default: true
      host_urls: ["{{ hostvars['fleet-01-srv']['ansible_host'] }}:8220"]
    status_code: [200, 409] # 409 might occur if already exists (though API might not return 409 for this POST, standardizing on idempotent-ish behavior)
 
  # Actually, the user's curl is a POST. If it already exists, we might want to update it or ignore.
  # Let's assume standard behavior. If strict, I should remove failed_when: false and handle status codes.
  # But for now, to ensure flow continues, I'll risk standard behavior or check result. 
  # Actually, let's look at the fields: POST to /fleet_server_hosts usually creates a new one. 
  # If we want to make it default, we set is_default: true.
  # Providing a unique name 'fleet-01-srv' might cause conflict if run twice. 
  # Ideally we should check if it exists or use a PUT? 
  # The user provided a POST. I will stick to POST. 
  # I'll remove the comment about 409 pending verification, but usually POSTing same name is error.
  register: set_default_fleet_result
  changed_when: set_default_fleet_result.status == 200
  failed_when: set_default_fleet_result.status != 200 and set_default_fleet_result.status != 409 

